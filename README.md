## What is it?

This is a Clojure based implementation of a logical programming language from [SICP](https://web.mit.edu/6.001/6.037/sicp.pdf) (subsection 4.4 "Logic Programming").

## Prerequisites

One needs to have Clojure and Leiningen preinstalled on your machine

## How can one run it?

To run the driver loop processing queries:

1. Navigate to the root directory of the repository
2. Execute the command: `lein run path/to/database`
   
Where `database` is a file containing a collection of assertions and rules (see Database Examples section).

## Database Examples

The `./examples` directory contains sample databases, primarily derived from SICP. One can practice excersizes from SICP with these databases.


## Difference from the Scheme based implementation from SICP

1. A primary divergence from the reference SICP implementation concerns the `lisp-value` special form. `lisp-value` special form is replaced by the `clojure-predicate` special form with similar semantics. The difference is that `clojure-predicate` takes a quoted Clojure form specifying a predicate, e.g. `"#(> % 0)"`, while the `lisp-value` takes unquoted Scheme form;
2. This implementation supports `is` special form which works as `is` from Prolog. `is` implements imperative arithmetics. Its first argument is a variable and the second argument is an arithmetic expression which can include variables. `is` evaluates second argument to a number and then unify its first argument (variable) with the obtained number. All the variables from the second argument must be instantiated by the time `is` is evaluated. See `examples/domain` for a concrete example.
3. This implementation supports the `eq` special form, which enables declarative arithmetic: one does not need both arguments of `eq` to be instantiated. While it can demonstrate some interesting deductive behavior, it remains a proof-of-concept with significant limitations. The system is based on constraint propagation, which is comparatively weak when measured against modern constraint programming frameworks. Modern frameworks employ a wide range of techniques for constraint resolution, including Linear Programming (LP). Here main limitation of the `eq` special form:
   - Only linear expressions are allowed in `eq` form, e.g. `(eq (3 * (+ (* 2 ?x) (/ 1 2))) (* (3 / 2) 7 (- ?x ?y)` is allowed, while `(eq (* ?x (+ ?y 1)) ?y)` is not;
   - The given constraints system lacks support for relational operators such as `>`, `>=`, `<`, and `<=`, a limitation that stems from the underlying constraint propagation system (in general case it requires LP). Although one can resort to the `clojure-predicate` special form, in many nontrivial cases this approach results in divergent computations. For example, in the `./examples/numbers` database, the query `(and (number ?x) (clojure-predicate "<" ?x 10))` produces the correct results but eventually fails with a `StackOverflowError`. This happens because the `clojure-predicate` form continues to traverse the infinite stream of numbers generated by `(number ?x)` even after all valid solutions have been found;
   - Not all constraints can be resolved with constraints propagation. E.g. for a rule `(rule (fail ?x ?y) (and (eq (+ ?x ?y) 2) (eq (- ?x ?y) 0)))` the query `(fail ?x ?y)` will keep `?x` and `?y` unbound outputing `(fail ?x ?y)` (see `./examples/cp_fail`), altough the result must be `(fail 1 1)`. To be able to resolve this kind of examples one needs Gauss elimination or a similar technique, which is not a big deal to implement, but my goal was to play with constraints propagation;
4. This implementation supports the `range` special form which can be used as `(range ?x)`, `(range ?x start)`, `(range ?x start end)` or `(range ?x start end step)`. It matches `?x` with a stream of numbers from a given range, default values of parameters `(= start 0)` `(= end inf)` `(= step 1)` are used if they are not supplied. Note that all the parameters must be instantiated. See `./examples/range` for a particular example.
5. This implementation supports `in` and `collect` special forms. `in` special form unifies its first argument with every element of its second argument. Note, that second argument must be either variable bound to a list or a list. Semantically, this form checks whether the first argument belongs to the set denoted by the second argument. See `./examples/common_elements` for a use case. The `collect` form is sort of an inverse. It collects matches into a list. See `./examples/collect_numbers` for a use case;
6. This implementation supprots `=` which simply unifies its first argument with its second argument.

## TODO

1. Loops detection in deduction chains (see Exercise 4.67 from SICP) and memoization to prevent recomputing of already evaluated queries;
2. The `and` special form performance optimization outlined in Exercise 4.76 of SICP;
